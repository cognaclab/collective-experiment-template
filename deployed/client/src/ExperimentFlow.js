/**
 * ExperimentFlow - Controls scene transitions based on sequence definition
 * Auto-generated by scene generation pipeline
 */

class ExperimentFlow {
    constructor(game) {
        this.game = game;
        this.sequence = [
        {
                "scene": "welcome",
                "type": "instruction",
                "content": "welcome.md",
                "next": "game_main"
        },
        {
                "scene": "game_main",
                "type": "game",
                "environment": "static",
                "trials": 3,
                "next": "questionnaire"
        },
        {
                "scene": "questionnaire",
                "type": "questionnaire",
                "next": "end"
        },
        {
                "scene": "end",
                "type": "completion"
        }
];
        this.currentSceneIndex = 0;
        this.sceneHistory = [];
    }

    start() {
        const firstScene = this.sequence[0];
        this.startScene(firstScene);
    }

    startScene(sceneConfig) {
        console.log('ExperimentFlow: Starting scene:', sceneConfig.scene);
        
        // Store in history
        this.sceneHistory.push(sceneConfig.scene);
        
        // Determine scene key based on type
        let sceneKey;
        if (sceneConfig.type === 'instruction') {
            sceneKey = `Generated${sceneConfig.scene}`;
        } else {
            // For complex scenes, use existing Phaser scene names
            sceneKey = this.mapToExistingScene(sceneConfig);
        }
        
        // Start the scene
        this.game.scene.start(sceneKey, {
            sceneConfig: sceneConfig,
            flow: this
        });
    }

    next(currentSceneKey) {
        // Find current scene in sequence
        const currentIndex = this.sequence.findIndex(scene => 
            scene.scene === currentSceneKey || 
            `Generated${scene.scene}` === currentSceneKey
        );
        
        if (currentIndex < 0) {
            console.error('Current scene not found in sequence:', currentSceneKey);
            return;
        }
        
        const nextIndex = currentIndex + 1;
        if (nextIndex < this.sequence.length) {
            const nextScene = this.sequence[nextIndex];
            this.startScene(nextScene);
        } else {
            console.log('Experiment completed!');
        }
    }

    mapToExistingScene(sceneConfig) {
        // Map sequence scene names to existing Phaser scene keys
        const sceneMap = {
            'tutorial_practice': 'SceneTutorial',
            'waiting_room': 'SceneWaitingRoom',
            'game_round_1': 'SceneMain',
            'game_round_2': 'SceneMain',
            'questionnaire': 'SceneGoToQuestionnaire'
        };
        
        return sceneMap[sceneConfig.scene] || sceneConfig.scene;
    }
}

export default ExperimentFlow;
